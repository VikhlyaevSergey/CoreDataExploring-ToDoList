//
//  TableViewControllerWorker.swift
//  ToDoList
//
//  Created by Сергей Вихляев on 03.05.2020.
//  Copyright (c) 2020 Сергей Вихляев. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData

// Maybe it will be nessessary later
class CoreDataError: Error {
    
    fileprivate let noObjectMessageCase = "Object for"
    
    enum CoreDataErrorCase {
        case noObject(String)
        case noEntity(String)
        case savingFalure
        case savingFalureWhileDeleting
        case dataBaseIsNotAvalible
    }
    
    let message: String
    let code: Int
    
    init(errorCase: CoreDataErrorCase) {
        switch errorCase  {
        case .noObject(let objectKey):
            message = "Object with class: \(objectKey) can't be fetched from DataBase"
            code = 1
        case .noEntity(let entityName):
            message = "Entity for key: \(entityName) did't found"
            code = 2
        case .savingFalure:
            message = "Entity can't be saved"
            code = 3
        case .savingFalureWhileDeleting:
            message = "Deleting was break in process. Reload or reinstall app"
            code = 4
        case .dataBaseIsNotAvalible:
            message = "Data Base can't be downloaded. DB will be clean..."
            code = 5
        
        }
    }
}
// -

class TableViewControllerWorker {
    
    lazy var context: NSManagedObjectContext = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
    
    func getSavedTasks(completion: (Bool, [Task]?, Error?, CoreDataError?) -> ()) {
        let fetchRequest: NSFetchRequest<Task> = Task.fetchRequest()
        let sortDescriptor = NSSortDescriptor(key: "title", ascending: false) // posibly here is we need use some like dateOfCreating...
        fetchRequest.sortDescriptors = [sortDescriptor]
        
        // get
        do {
            let tasks = try context.fetch(fetchRequest)
            completion(true, tasks, nil, nil)
        } catch let error as NSError {
            completion(false, nil, error, CoreDataError(errorCase: .dataBaseIsNotAvalible))
        }
    }
    
    func addTask(withTitle title: String, completion: (Bool, Task?, Error?, CoreDataError?) -> ()) {
        let entityName = "Task"
        guard let entity = NSEntityDescription.entity(forEntityName: "Task", in: context) else {
            completion(false, nil, nil, CoreDataError(errorCase: .noEntity(entityName)))
            return
        }
        
        let taskObject = Task(entity: entity, insertInto: context)
        taskObject.title = title
        
        // save
        do {
            try context.save()
            completion(true, taskObject, nil, nil)
        } catch let error as NSError {
            completion(false, nil, error, CoreDataError(errorCase: .savingFalure))
        }
        //
    }
    
    func deleteAll(completion: (Bool, Error?, CoreDataError?) -> ()) {
        let fetchRequest: NSFetchRequest<Task> = Task.fetchRequest()
        if let objects = try? context.fetch(fetchRequest) {
            for object in objects {
                context.delete(object)
            }
        }
        
        // save
        do {
            try context.save()
            completion(true, nil, nil)
        } catch let error as NSError {
            completion(false, error, CoreDataError(errorCase: .savingFalureWhileDeleting))
        }
        //
    }
}
